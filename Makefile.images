# Shared target to build images.
# To build an image, simply add a dependency on the target `package/.image.<abc>`
# where <abc> corresponds to an existing `package/Dockerfile.<abc>` file.
# The resulting image name will be `<abc>`.

SHELL := /bin/bash

# Force rebuild an image if it's not in docker
force_image_rebuild = $(if $(shell docker images | grep '\<$(1)\W*latest\>'),,FORCE_IMAGE)

# Force rebuild dynamically by calling this target
FORCE_IMAGE: ;

# Dockerfile dependencies are the file and any file copied into it
# We have to run it through a variable in order to expand any * that might be
# in the COPY command; find is used to handle directories as dependencies
# Files copied from another image are ignored
docker_deps = $(shell files=($(1) $$(awk '/COPY/ && substr($$2, 1, 7) != "--from=" && $$2 != "." { $$1 = $$NF = ""; print }' $(1))) && find $${files[*]} -type f -o -type l)

# Patterned recipe to use to build any image from any Dockerfile
# An empty file is used for make to figure out if dependencies changed or not
.SECONDEXPANSION:
package/.image.%: $$(call docker_deps,package/Dockerfile.$$*) $$(call force_image_rebuild,$$*)
	$(SCRIPTS_DIR)/build_image.sh -i $(lastword $(subst ., ,$@)) -f $< -h $@ $(IMAGES_ARGS)

# Build an OCI tarball from a Dockerfile
.SECONDEXPANSION:
package/%.tar: $$(call docker_deps,package/Dockerfile.$$*) $$(call force_image_rebuid,$$*)
	image=$(firstword $(subst ., ,$(@F))) && \
	$(SCRIPTS_DIR)/build_image.sh -i $$image -f $< --oci $@ -h package/.image.$$image $(IMAGES_ARGS)

# [images] builds all the container images for the project
# Default target to build images based on IMAGES variable
images: $(foreach image,$(IMAGES),package/.image.$(image))

# [multiarch-images] builds all multi-arch container images
# Default target to build images based on the MULTIARCH_IMAGES variable
# Default platforms based on the PLATFORMS variable
multiarch-images: override IMAGES_ARGS += --platform $(PLATFORMS)
multiarch-images: $(foreach image,$(MULTIARCH_IMAGES),package/$(image).tar)

# [release-images] uploads the project's images to a public repository
release-images:
ifneq (,$(filter-out ($MULTIARCH_IMAGES),$(IMAGES)))
	$(SCRIPTS_DIR)/release_images.sh $(filter-out $(MULTIARCH_IMAGES),$(IMAGES)) $(RELEASE_ARGS)
endif
ifneq (,$(MULTIARCH_IMAGES))
	$(SCRIPTS_DIR)/release_images.sh --oci package/ $(MULTIARCH_IMAGES) $(RELEASE_ARGS)
endif

.PHONY: images multiarch-images release-images
